<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: context/AuthContext.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: context/AuthContext.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Authentication Context Provider
 * 
 * Centralized authentication state management using React Context API.
 * Provides authentication state, user information, and auth operations
 * (login, logout, register) to all components in the application tree.
 * 
 * Architecture Pattern: Context + Service Layer
 * - Context: Global state management
 * - Service Layer: API communication (AuthService)
 * - Separation of Concerns: UI state vs business logic
 * 
 * Features:
 * - Global authentication state management
 * - Automatic token verification on app load
 * - Persistent login with localStorage
 * - Loading states for async operations
 * - Error state management
 * - Type-safe context access via custom hook
 * 
 * State Management:
 * - user: Current authenticated user object (null if not logged in)
 * - loading: True during authentication operations
 * - error: Error messages from auth operations
 * - isAuthenticated: Computed boolean from user state
 * 
 * Lifecycle:
 * 1. App mounts → Provider initializes
 * 2. Check localStorage for existing token
 * 3. Verify token validity with backend
 * 4. Restore user session or clear invalid token
 * 5. Provide auth state to child components
 * 
 * Security Considerations:
 * - Token stored securely via AuthService/TokenManager
 * - Automatic token cleanup on verification failure
 * - No sensitive data in context (only user info)
 * - Token transmitted via HTTPS only
 * 
 * Performance:
 * - Single context instance (no unnecessary re-renders)
 * - Memoized context value
 * - Async operations properly managed
 * - Loading states prevent UI flicker
 * 
 * @module context/AuthContext
 * @requires react
 * @requires ../services/AuthService
 * 
 * @author mr.shaan
 * @version 1.0.0
 * @since 2025-12-16
 * 
 * @example
 * // Wrap app with AuthProvider
 * import { AuthProvider } from './context/AuthContext';
 * 
 * function App() {
 *   return (
 *     &lt;AuthProvider>
 *       &lt;YourApp />
 *     &lt;/AuthProvider>
 *   );
 * }
 * 
 * @example
 * // Use auth in components
 * import { useAuth } from './context/AuthContext';
 * 
 * function Profile() {
 *   const { user, logout, isAuthenticated } = useAuth();
 *   
 *   if (!isAuthenticated) return &lt;Redirect to="/login" />;
 *   
 *   return (
 *     &lt;div>
 *       &lt;h1>Welcome, {user.name}&lt;/h1>
 *       &lt;button onClick={logout}>Logout&lt;/button>
 *     &lt;/div>
 *   );
 * }
 */

import React, { createContext, useContext, useState, useEffect } from 'react';
import AuthService from '../services/AuthService';


/**
 * Authentication Context
 * 
 * Context object that holds authentication state and operations.
 * Initially null - must be accessed via useAuth hook which validates provider existence.
 * 
 * Context Value Shape:
 * @typedef {Object} AuthContextValue
 * @property {Object|null} user - Current authenticated user object
 * @property {boolean} loading - Loading state during auth operations
 * @property {string|null} error - Error message from last operation
 * @property {Function} register - Register new user function
 * @property {Function} login - Login user function
 * @property {Function} logout - Logout user function
 * @property {boolean} isAuthenticated - Computed authentication status
 * 
 * @type {React.Context&lt;AuthContextValue|null>}
 */
const AuthContext = createContext(null);


/**
 * AuthProvider Component
 * 
 * Context provider that manages global authentication state and provides
 * auth operations to all child components. Automatically verifies stored
 * tokens on mount and maintains authentication state throughout app lifecycle.
 * 
 * Initialization Flow:
 * 1. Component mounts
 * 2. useEffect triggers initializeAuth()
 * 3. Check if token exists in storage
 * 4. Retrieve stored user data
 * 5. Verify token validity with backend
 * 6. Restore session or clear invalid data
 * 7. Set loading to false
 * 8. Render children with context
 * 
 * State Updates:
 * - user: Set on login/register, cleared on logout/error
 * - loading: True during async operations, false otherwise
 * - error: Set on operation failure, cleared on new operation
 * 
 * Re-render Optimization:
 * - Context value computed each render
 * - Consider useMemo for production optimization
 * - Children only re-render when context value changes
 * 
 * @component
 * @param {Object} props - Component properties
 * @param {React.ReactNode} props.children - Child components to receive context
 * 
 * @returns {React.ReactElement} Provider wrapping children with auth context
 * 
 * @example
 * // Basic usage in root component
 * import { AuthProvider } from './context/AuthContext';
 * 
 * function Root() {
 *   return (
 *     &lt;AuthProvider>
 *       &lt;App />
 *     &lt;/AuthProvider>
 *   );
 * }
 * 
 * @example
 * // With router
 * function Root() {
 *   return (
 *     &lt;BrowserRouter>
 *       &lt;AuthProvider>
 *         &lt;Routes>
 *           &lt;Route path="/login" element={&lt;Login />} />
 *           &lt;Route path="/dashboard" element={&lt;Dashboard />} />
 *         &lt;/Routes>
 *       &lt;/AuthProvider>
 *     &lt;/BrowserRouter>
 *   );
 * }
 */
export const AuthProvider = ({ children }) => {
  /**
   * Current authenticated user state
   * @type {[Object|null, Function]}
   * @property {Object|null} user - User object from backend (id, name, email, etc.)
   * @property {Function} setUser - State setter function
   */
  const [user, setUser] = useState(null);
  
  /**
   * Loading state for async authentication operations
   * @type {[boolean, Function]}
   * @property {boolean} loading - True during auth operations
   * @property {Function} setLoading - State setter function
   */
  const [loading, setLoading] = useState(true);
  
  /**
   * Error state for authentication operation failures
   * @type {[string|null, Function]}
   * @property {string|null} error - Error message or null
   * @property {Function} setError - State setter function
   */
  const [error, setError] = useState(null);


  /**
   * Initialize authentication state on component mount
   * 
   * Runs once when AuthProvider mounts (app startup).
   * Attempts to restore previous authentication session
   * from localStorage and verify token validity.
   * 
   * @effect
   * @listens componentDidMount
   */
  useEffect(() => {
    initializeAuth();
  }, []);


  /**
   * Initialize authentication state from stored credentials
   * 
   * Checks for existing authentication token in localStorage,
   * retrieves stored user data, and verifies token validity
   * with the backend API. Handles expired or invalid tokens
   * by clearing stored data.
   * 
   * Process:
   * 1. Check AuthService.isAuthenticated() (token exists?)
   * 2. Get stored user data from localStorage
   * 3. Set user state optimistically
   * 4. Verify token with backend API call
   * 5. On success: User remains logged in
   * 6. On failure: Clear user state, remove token
   * 7. Set loading to false
   * 
   * Error Scenarios:
   * - Token expired: Clears session, user must login
   * - Token invalid: Clears session, user must login
   * - Network error: Logs error, attempts to continue
   * - Server error: Clears session for security
   * 
   * @async
   * @function initializeAuth
   * @returns {Promise&lt;void>}
   * 
   * @throws {Error} Catches all errors, logs them, clears auth state
   * 
   * @example
   * // Called automatically on mount
   * useEffect(() => {
   *   initializeAuth();
   * }, []);
   */
  const initializeAuth = async () => {
    try {
      // Check if token exists in localStorage
      if (AuthService.isAuthenticated()) {
        // Retrieve stored user data
        const currentUser = AuthService.getCurrentUser();
        setUser(currentUser);
        
        // Verify token is still valid with backend
        // Throws error if token expired or invalid
        await AuthService.verifyToken();
      }
    } catch (error) {
      // Token verification failed - clear auth state
      console.error('Auth initialization failed:', error);
      setUser(null);
      // AuthService.logout() called internally to clear storage
    } finally {
      // Always set loading to false, even on error
      setLoading(false);
    }
  };


  /**
   * Register new user account
   * 
   * Creates a new user account via backend API. Does NOT automatically
   * log the user in after registration - user must login separately.
   * This allows for email verification workflows if needed.
   * 
   * Registration Flow:
   * 1. Clear previous errors
   * 2. Set loading state
   * 3. Call AuthService.register() with user data
   * 4. Backend creates user account
   * 5. Return success response
   * 6. User redirected to login (not auto-logged in)
   * 
   * Validation:
   * - Client-side validation in form component
   * - Server-side validation in backend API
   * - Duplicate email detection server-side
   * 
   * @async
   * @function register
   * @param {Object} userData - User registration data
   * @param {string} userData.name - User's full name
   * @param {string} userData.email - User's email address (unique)
   * @param {string} userData.password - User's password (min 8 chars)
   * @param {string} [userData.contact] - Optional contact number
   * 
   * @returns {Promise&lt;Object>} Registration response from backend
   * @returns {boolean} return.success - Registration success status
   * @returns {string} return.message - Success or error message
   * @returns {Object} [return.data] - Created user data (no password)
   * 
   * @throws {Error} Registration errors (duplicate email, validation, etc.)
   * 
   * @example
   * const { register } = useAuth();
   * 
   * try {
   *   const response = await register({
   *     name: 'John Doe',
   *     email: 'john@example.com',
   *     password: 'SecurePass123',
   *     contact: '+1234567890'
   *   });
   *   
   *   console.log('Registration successful');
   *   navigate('/login');
   * } catch (error) {
   *   console.error('Registration failed:', error.message);
   * }
   */
  const register = async (userData) => {
    try {
      setError(null);           // Clear previous errors
      setLoading(true);          // Show loading state
      
      // Call AuthService to register user
      const response = await AuthService.register(userData);
      
      // Return response (user not logged in automatically)
      return response;
    } catch (error) {
      // Set error state for UI display
      setError(error.message);
      // Re-throw error for component-level handling
      throw error;
    } finally {
      // Always clear loading state
      setLoading(false);
    }
  };


  /**
   * Login user with credentials
   * 
   * Authenticates user with email and password, receives JWT token,
   * stores token and user data, and updates context state.
   * 
   * Login Flow:
   * 1. Clear previous errors
   * 2. Set loading state
   * 3. Call AuthService.login() with credentials
   * 4. Backend validates credentials
   * 5. Backend returns JWT token + user data
   * 6. AuthService stores token in localStorage
   * 7. Update user state in context
   * 8. Components re-render with authenticated state
   * 
   * Security:
   * - Password transmitted over HTTPS
   * - JWT token returned and stored
   * - Token used for subsequent API calls
   * - Token auto-validated on app reload
   * 
   * @async
   * @function login
   * @param {Object} credentials - Login credentials
   * @param {string} credentials.email - User's email address
   * @param {string} credentials.password - User's password
   * 
   * @returns {Promise&lt;Object>} Login response from backend
   * @returns {boolean} return.success - Login success status
   * @returns {string} return.message - Success or error message
   * @returns {Object} return.data - Login data
   * @returns {string} return.data.token - JWT access token
   * @returns {Object} return.data.user - User object
   * 
   * @throws {Error} Authentication errors (invalid credentials, etc.)
   * 
   * @example
   * const { login } = useAuth();
   * 
   * const handleLogin = async (e) => {
   *   e.preventDefault();
   *   try {
   *     await login({
   *       email: 'john@example.com',
   *       password: 'SecurePass123'
   *     });
   *     navigate('/dashboard');
   *   } catch (error) {
   *     setFormError(error.message);
   *   }
   * };
   */
  const login = async (credentials) => {
    try {
      setError(null);           // Clear previous errors
      setLoading(true);          // Show loading state
      
      // Call AuthService to authenticate user
      const response = await AuthService.login(credentials);
      
      // Update user state with authenticated user data
      setUser(response.data.user);
      
      // Return full response for component use
      return response;
    } catch (error) {
      // Set error state for UI display
      setError(error.message);
      // Re-throw error for component-level handling
      throw error;
    } finally {
      // Always clear loading state
      setLoading(false);
    }
  };


  /**
   * Logout current user
   * 
   * Logs out the current user by invalidating the session on the backend,
   * clearing stored tokens, and resetting authentication state.
   * 
   * Logout Flow:
   * 1. Set loading state
   * 2. Call AuthService.logout() to invalidate server session
   * 3. AuthService clears localStorage (token, user data)
   * 4. Clear user state in context
   * 5. Components re-render with unauthenticated state
   * 6. Protected routes redirect to login
   * 
   * Error Handling:
   * - Even if API call fails, clear local state
   * - Ensures user appears logged out in UI
   * - Prevents security issues from failed logout
   * 
   * @async
   * @function logout
   * @returns {Promise&lt;void>}
   * 
   * @example
   * const { logout } = useAuth();
   * 
   * const handleLogout = async () => {
   *   await logout();
   *   navigate('/login');
   * };
   * 
   * @example
   * // With confirmation
   * const handleLogout = async () => {
   *   if (confirm('Are you sure you want to logout?')) {
   *     await logout();
   *     navigate('/');
   *   }
   * };
   */
  const logout = async () => {
    try {
      setLoading(true);          // Show loading state
      
      // Call AuthService to invalidate session
      // Also clears localStorage
      await AuthService.logout();
    } catch (error) {
      // Log error but don't prevent logout
      console.error('Logout error:', error);
    } finally {
      // Always clear user state (even on error)
      setUser(null);
      setLoading(false);
    }
  };


  /**
   * Context value object
   * 
   * Contains all authentication state and operations provided to consumers.
   * This object is passed to all components via Context Provider.
   * 
   * Consider wrapping in useMemo for production:
   * const value = useMemo(() => ({ ... }), [user, loading, error]);
   * 
   * @type {AuthContextValue}
   */
  const value = {
    user,                        // Current user object or null
    loading,                     // Loading state
    error,                       // Error message or null
    register,                    // Register function
    login,                       // Login function
    logout,                      // Logout function
    isAuthenticated: !!user,     // Computed boolean from user state
  };


  /**
   * Render Provider
   * 
   * Wraps children with Context Provider, making auth state
   * and operations available to all descendant components.
   */
  return (
    &lt;AuthContext.Provider value={value}>
      {children}
    &lt;/AuthContext.Provider>
  );
};


/**
 * Custom hook to access authentication context
 * 
 * Provides type-safe access to authentication context with automatic
 * validation that the hook is used within an AuthProvider.
 * 
 * Validation:
 * - Checks if context exists (not null)
 * - Throws descriptive error if used outside provider
 * - Prevents runtime errors from undefined context
 * 
 * Usage Pattern:
 * This is the ONLY way to access AuthContext. Direct useContext(AuthContext)
 * usage is discouraged as it bypasses validation.
 * 
 * @function useAuth
 * @returns {AuthContextValue} Authentication context value
 * @returns {Object|null} return.user - Current authenticated user
 * @returns {boolean} return.loading - Loading state
 * @returns {string|null} return.error - Error message
 * @returns {Function} return.register - Register function
 * @returns {Function} return.login - Login function
 * @returns {Function} return.logout - Logout function
 * @returns {boolean} return.isAuthenticated - Authentication status
 * 
 * @throws {Error} If used outside AuthProvider
 * 
 * @example
 * // Correct usage
 * import { useAuth } from './context/AuthContext';
 * 
 * function MyComponent() {
 *   const { user, isAuthenticated, logout } = useAuth();
 *   
 *   if (!isAuthenticated) {
 *     return &lt;p>Please login&lt;/p>;
 *   }
 *   
 *   return (
 *     &lt;div>
 *       &lt;p>Welcome, {user.name}&lt;/p>
 *       &lt;button onClick={logout}>Logout&lt;/button>
 *     &lt;/div>
 *   );
 * }
 * 
 * @example
 * // Error case - throws error
 * function BrokenComponent() {
 *   // ❌ Used outside AuthProvider
 *   const { user } = useAuth(); // Throws: "useAuth must be used within AuthProvider"
 * }
 */
export const useAuth = () => {
  const context = useContext(AuthContext);
  
  // Validate context exists
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_auth_LoginForm.html">components/auth/LoginForm</a></li><li><a href="module-components_auth_SignupForm.html">components/auth/SignupForm</a></li><li><a href="module-components_common_Input.html">components/common/Input</a></li><li><a href="module-components_common_ProtectedRoute.html">components/common/ProtectedRoute</a></li><li><a href="module-components_layout_Header.html">components/layout/Header</a></li><li><a href="module-context_AuthContext.html">context/AuthContext</a></li><li><a href="module-services_ApiClient.html">services/ApiClient</a></li><li><a href="module-services_AuthService.html">services/AuthService</a></li><li><a href="module-utils_TokenManager.html">utils/TokenManager</a></li></ul><h3>Classes</h3><ul><li><a href="module-services_ApiClient-ApiClient.html">ApiClient</a></li><li><a href="module-services_AuthService-AuthService.html">AuthService</a></li><li><a href="module-utils_TokenManager-TokenManager.html">TokenManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Dec 16 2025 02:17:08 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

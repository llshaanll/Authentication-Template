<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/AuthService.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/AuthService.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Authentication Service
 * 
 * Service layer that handles all authentication-related business logic and API
 * communications. Implements SOLID principles and acts as an intermediary between
 * UI components (via AuthContext) and backend API (via ApiClient).
 * 
 * SOLID Principles Implementation:
 * 
 * 1. Single Responsibility Principle (SRP):
 *    - Only handles authentication operations
 *    - Delegates API calls to ApiClient
 *    - Delegates token storage to TokenManager
 * 
 * 2. Open/Closed Principle (OCP):
 *    - Open for extension (can add new auth methods)
 *    - Closed for modification (existing methods stable)
 * 
 * 3. Liskov Substitution Principle (LSP):
 *    - Can be replaced with mock implementation for testing
 *    - Interface contract maintained
 * 
 * 4. Interface Segregation Principle (ISP):
 *    - Specific methods for each auth operation
 *    - No monolithic "handleAuth" method
 *    - Clients only use what they need
 * 
 * 5. Dependency Inversion Principle (DIP):
 *    - Depends on ApiClient abstraction, not concrete implementation
 *    - Depends on TokenManager abstraction
 *    - High-level module doesn't depend on low-level details
 * 
 * Architecture Pattern: Service Layer
 * - Separates business logic from UI components
 * - Provides clean API for authentication operations
 * - Centralizes error handling and data transformation
 * - Makes testing easier (can mock service layer)
 * 
 * Features:
 * - User registration with validation
 * - User login with JWT token management
 * - User logout with session cleanup
 * - Token verification and validation
 * - Authentication state checking
 * - Centralized error handling
 * - Automatic token storage/retrieval
 * 
 * Security Features:
 * - Secure token storage via TokenManager
 * - Automatic token injection via ApiClient
 * - Token cleanup on logout/errors
 * - Server-side token validation
 * - No password storage (only transmitted)
 * 
 * Error Handling Strategy:
 * - Catch all API errors
 * - Extract meaningful error messages
 * - Re-throw as Error objects
 * - Log errors for debugging
 * - Always cleanup on failure
 * 
 * @module services/AuthService
 * @requires ./ApiClient
 * @requires ../utils/TokenManager
 * 
 * @author mr.shaan
 * @version 1.0.0
 * @since 2025-12-16
 * 
 * @example
 * // Import and use in AuthContext
 * import AuthService from './services/AuthService';
 * 
 * const login = async (credentials) => {
 *   try {
 *     const response = await AuthService.login(credentials);
 *     setUser(response.data.user);
 *   } catch (error) {
 *     setError(error.message);
 *   }
 * };
 * 
 * @example
 * // Check authentication status
 * if (AuthService.isAuthenticated()) {
 *   const user = AuthService.getCurrentUser();
 *   console.log('Logged in as:', user.name);
 * }
 */

import ApiClient from './ApiClient';
import TokenManager from '../utils/TokenManager';


/**
 * AuthService Class
 * 
 * Singleton service that encapsulates all authentication-related operations.
 * Provides a clean, consistent API for user registration, login, logout,
 * and token management.
 * 
 * Design Pattern: Singleton
 * - Single instance shared across application
 * - Consistent state management
 * - Centralized configuration
 * 
 * Dependencies:
 * - ApiClient: HTTP communication layer
 * - TokenManager: Token storage and retrieval
 * 
 * State Management:
 * - Stateless service (state stored in TokenManager/localStorage)
 * - No internal state to maintain
 * - Each method is independent
 * 
 * @class AuthService
 * 
 * @example
 * // Service is exported as singleton
 * import AuthService from './services/AuthService';
 * 
 * // Use directly without instantiation
 * await AuthService.login({ email, password });
 */
class AuthService {
  /**
   * Initializes AuthService with ApiClient dependency
   * 
   * Constructor sets up the service with required dependencies.
   * Uses dependency injection pattern for testability.
   * 
   * @constructor
   * 
   * @example
   * // Internal instantiation (singleton pattern)
   * const authService = new AuthService();
   * export default authService;
   */
  constructor() {
    /**
     * API client instance for HTTP requests
     * @type {ApiClient}
     * @private
     */
    this.apiClient = ApiClient;
  }


  /**
   * Register a new user account
   * 
   * Creates a new user account in the system. Does NOT automatically
   * log the user in after registration, allowing for email verification
   * workflows or explicit login requirements.
   * 
   * Registration Flow:
   * 1. Validate user data (client-side in form)
   * 2. Send POST request to /auth/register
   * 3. Backend validates data (unique email, password strength, etc.)
   * 4. Backend creates user record in database
   * 5. Return success response (no token)
   * 6. User redirected to login page
   * 
   * Validation (Backend):
   * - Email: Valid format, unique, required
   * - Password: Minimum length, strength requirements
   * - Name: Required, string
   * - Contact: Optional, valid format if provided
   * 
   * Error Scenarios:
   * - Duplicate email (409 Conflict)
   * - Invalid data format (400 Bad Request)
   * - Server error (500 Internal Server Error)
   * 
   * @async
   * @method register
   * @param {Object} userData - User registration data
   * @param {string} userData.name - User's full name
   * @param {string} userData.email - User's email address (must be unique)
   * @param {string} userData.password - User's password (min 8 characters)
   * @param {string} [userData.contact] - Optional contact number
   * 
   * @returns {Promise&lt;Object>} Registration response
   * @returns {boolean} return.success - Registration success status
   * @returns {string} return.message - Success or error message
   * @returns {Object} [return.data] - User data (without password)
   * 
   * @throws {Error} Registration failed with error message from backend
   * 
   * @example
   * // Basic registration
   * try {
   *   const response = await AuthService.register({
   *     name: 'John Doe',
   *     email: 'john@example.com',
   *     password: 'SecurePass123',
   *     contact: '+1234567890'
   *   });
   *   
   *   console.log('Registration successful:', response.message);
   *   navigate('/login');
   * } catch (error) {
   *   console.error('Registration failed:', error.message);
   * }
   * 
   * @example
   * // With form validation
   * const handleRegister = async (formData) => {
   *   // Client-side validation first
   *   if (!isValidEmail(formData.email)) {
   *     return setError('Invalid email format');
   *   }
   *   
   *   try {
   *     await AuthService.register(formData);
   *     setSuccess('Registration successful! Please login.');
   *   } catch (error) {
   *     if (error.message.includes('exists')) {
   *       setError('Email already registered');
   *     } else {
   *       setError(error.message);
   *     }
   *   }
   * };
   */
  async register(userData) {
    try {
      // Send registration request to backend API
      const response = await this.apiClient.post('/auth/register', userData);
      
      // Return response data to caller
      // No token saved - user must login separately
      return response.data;
    } catch (error) {
      // Handle and re-throw error with meaningful message
      throw this._handleError(error);
    }
  }


  /**
   * Authenticate user and create session
   * 
   * Authenticates user with email/password credentials, receives JWT token,
   * and stores authentication data in localStorage for persistent login.
   * 
   * Login Flow:
   * 1. Send POST request with credentials
   * 2. Backend validates credentials against database
   * 3. Backend generates JWT token
   * 4. Backend creates session record
   * 5. Return token + user data
   * 6. Save token and user to localStorage
   * 7. Update AuthContext state
   * 8. Redirect to dashboard/intended page
   * 
   * Token Storage:
   * - JWT token stored in localStorage (key: 'token')
   * - User object stored in localStorage (key: 'user')
   * - Token automatically injected in API requests
   * - Token validated on app reload
   * 
   * Security Considerations:
   * - Password never stored (only transmitted once)
   * - Token transmitted over HTTPS
   * - Token has expiration time (JWT exp claim)
   * - Token can be invalidated server-side
   * 
   * @async
   * @method login
   * @param {Object} credentials - Login credentials
   * @param {string} credentials.email - User's email address
   * @param {string} credentials.password - User's password
   * 
   * @returns {Promise&lt;Object>} Login response with token and user data
   * @returns {boolean} return.success - Login success status
   * @returns {string} return.message - Success message
   * @returns {Object} return.data - Authentication data
   * @returns {string} return.data.token - JWT access token
   * @returns {Object} return.data.user - User object
   * @returns {string} return.data.user.id - User ID (UUID)
   * @returns {string} return.data.user.name - User's full name
   * @returns {string} return.data.user.email - User's email
   * 
   * @throws {Error} Authentication failed with error message
   * 
   * @example
   * // Basic login
   * try {
   *   const response = await AuthService.login({
   *     email: 'john@example.com',
   *     password: 'SecurePass123'
   *   });
   *   
   *   console.log('Logged in as:', response.data.user.name);
   *   navigate('/dashboard');
   * } catch (error) {
   *   console.error('Login failed:', error.message);
   *   setError('Invalid email or password');
   * }
   * 
   * @example
   * // With loading state
   * const handleLogin = async (credentials) => {
   *   setLoading(true);
   *   try {
   *     const response = await AuthService.login(credentials);
   *     setUser(response.data.user);
   *     navigate('/dashboard');
   *   } catch (error) {
   *     setError(error.message);
   *   } finally {
   *     setLoading(false);
   *   }
   * };
   * 
   * @example
   * // With remember me functionality
   * const handleLogin = async (credentials, rememberMe) => {
   *   try {
   *     const response = await AuthService.login(credentials);
   *     
   *     if (rememberMe) {
   *       // Token already saved by AuthService
   *       console.log('Session will persist');
   *     } else {
   *       // Could implement session-only storage here
   *       console.log('Session for this browser session only');
   *     }
   *     
   *     navigate('/dashboard');
   *   } catch (error) {
   *     setError(error.message);
   *   }
   * };
   */
  async login(credentials) {
    try {
      // Send login request to backend API
      const response = await this.apiClient.post('/auth/login', credentials);
      
      // Extract token and user from response
      const { token, user } = response.data.data;
      
      // Save authentication data to localStorage
      // This enables persistent login across browser sessions
      TokenManager.saveAuthData(token, user);
      
      // Return full response to caller (for AuthContext)
      return response.data;
    } catch (error) {
      // Handle and re-throw error with meaningful message
      throw this._handleError(error);
    }
  }


  /**
   * Logout user and invalidate session
   * 
   * Logs out the current user by invalidating their session on the backend
   * and clearing all stored authentication data from localStorage.
   * 
   * Logout Flow:
   * 1. Send POST request to /auth/logout
   * 2. Backend invalidates current session in database
   * 3. Backend may invalidate token (if using token blacklist)
   * 4. Clear token from localStorage
   * 5. Clear user data from localStorage
   * 6. Update AuthContext state (user = null)
   * 7. Redirect to login page
   * 
   * Error Handling:
   * - Even if API call fails, still clear local data
   * - Ensures user appears logged out in UI
   * - Prevents security issues from failed logout
   * - Token won't work for future requests (401 from backend)
   * 
   * Cleanup Guarantees:
   * - localStorage always cleared (try/finally)
   * - User state always reset
   * - Protected routes become inaccessible
   * - API calls will fail with 401
   * 
   * @async
   * @method logout
   * @returns {Promise&lt;void>}
   * 
   * @example
   * // Basic logout
   * const handleLogout = async () => {
   *   await AuthService.logout();
   *   navigate('/login');
   * };
   * 
   * @example
   * // With confirmation
   * const handleLogout = async () => {
   *   if (confirm('Are you sure you want to logout?')) {
   *     try {
   *       await AuthService.logout();
   *       toast.success('Logged out successfully');
   *       navigate('/');
   *     } catch (error) {
   *       // Still logged out locally even if API fails
   *       toast.info('Logged out');
   *       navigate('/');
   *     }
   *   }
   * };
   * 
   * @example
   * // Logout all devices (different endpoint)
   * const handleLogoutAll = async () => {
   *   try {
   *     await ApiClient.post('/auth/logout/all');
   *     TokenManager.clearAuthData();
   *     navigate('/login');
   *   } catch (error) {
   *     console.error(error);
   *   }
   * };
   */
  async logout() {
    try {
      // Invalidate session on backend
      // This ensures token can't be used again
      await this.apiClient.post('/auth/logout');
    } catch (error) {
      // Log error but don't prevent logout
      // User should always be able to logout locally
      console.error('Logout error:', error);
    } finally {
      // ALWAYS clear local authentication data
      // This runs even if API call fails
      // Ensures user is logged out from client perspective
      TokenManager.clearAuthData();
    }
  }


  /**
   * Verify current authentication token
   * 
   * Validates the stored JWT token with the backend to ensure it's
   * still valid and the session is active. Called automatically on
   * app initialization to restore previous session.
   * 
   * Verification Flow:
   * 1. Token automatically sent via ApiClient interceptor
   * 2. Backend validates JWT signature
   * 3. Backend checks token expiration
   * 4. Backend verifies session exists in database
   * 5. Backend checks user still exists and is active
   * 6. Return verification response
   * 
   * Token Validation (Backend):
   * - JWT signature valid (not tampered)
   * - Token not expired (exp claim)
   * - Session exists in user_sessions table
   * - User account still active
   * - Token not in blacklist (if implemented)
   * 
   * Use Cases:
   * - App initialization (restore session)
   * - Periodic token refresh
   * - Before sensitive operations
   * - After coming back from idle
   * 
   * Error Handling:
   * - Invalid token: Clear auth data, throw error
   * - Expired token: Clear auth data, throw error
   * - Network error: Let caller handle
   * - Server error: Clear auth data (security measure)
   * 
   * @async
   * @method verifyToken
   * @returns {Promise&lt;Object>} Verification response
   * @returns {boolean} return.success - Verification success status
   * @returns {string} return.message - Verification message
   * @returns {Object} return.data - User data from token
   * 
   * @throws {Error} Token verification failed
   * 
   * @example
   * // Verify on app initialization
   * useEffect(() => {
   *   const initAuth = async () => {
   *     if (AuthService.isAuthenticated()) {
   *       try {
   *         await AuthService.verifyToken();
   *         const user = AuthService.getCurrentUser();
   *         setUser(user);
   *       } catch (error) {
   *         // Token invalid, user must login again
   *         console.log('Session expired');
   *       }
   *     }
   *     setLoading(false);
   *   };
   *   
   *   initAuth();
   * }, []);
   * 
   * @example
   * // Verify before sensitive operation
   * const handleDeleteAccount = async () => {
   *   try {
   *     // Verify token still valid
   *     await AuthService.verifyToken();
   *     
   *     // Proceed with deletion
   *     await deleteAccount();
   *   } catch (error) {
   *     // Token expired, redirect to login
   *     navigate('/login');
   *   }
   * };
   */
  async verifyToken() {
    try {
      // Send verification request to backend
      // Token automatically included via ApiClient interceptor
      const response = await this.apiClient.get('/auth/verify');
      
      // Return verification response
      return response.data;
    } catch (error) {
      // Token verification failed - clear auth data
      // This ensures invalid tokens don't persist
      TokenManager.clearAuthData();
      
      // Re-throw error for caller to handle
      throw this._handleError(error);
    }
  }


  /**
   * Get current authenticated user from localStorage
   * 
   * Retrieves the stored user object from localStorage without
   * making an API call. Returns cached user data.
   * 
   * Data Source:
   * - Retrieved from localStorage (key: 'user')
   * - Stored during login
   * - Cleared during logout
   * - Synchronized with backend user data
   * 
   * Use Cases:
   * - Display user info in UI
   * - Check user permissions/roles
   * - Populate forms with user data
   * - Show user profile
   * 
   * Note: This is cached data. For fresh data, call API endpoint.
   * 
   * @method getCurrentUser
   * @returns {Object|null} User object or null if not logged in
   * @returns {string} return.id - User ID (UUID)
   * @returns {string} return.name - User's full name
   * @returns {string} return.email - User's email address
   * @returns {string} [return.contact] - User's contact number
   * @returns {string} return.createdAt - Account creation timestamp
   * 
   * @example
   * // Get current user
   * const user = AuthService.getCurrentUser();
   * if (user) {
   *   console.log('Logged in as:', user.name);
   * } else {
   *   console.log('Not logged in');
   * }
   * 
   * @example
   * // Display in component
   * function Header() {
   *   const user = AuthService.getCurrentUser();
   *   
   *   return (
   *     &lt;header>
   *       {user ? (
   *         &lt;div>Welcome, {user.name}&lt;/div>
   *       ) : (
   *         &lt;Link to="/login">Login&lt;/Link>
   *       )}
   *     &lt;/header>
   *   );
   * }
   */
  getCurrentUser() {
    return TokenManager.getUser();
  }


  /**
   * Check if user is currently authenticated
   * 
   * Checks if a valid JWT token exists in localStorage.
   * Does NOT verify token validity with backend - only checks presence.
   * 
   * Check Logic:
   * - Returns true if token exists in localStorage
   * - Returns false if no token found
   * - Does not validate token signature or expiration
   * 
   * Use Cases:
   * - Quick authentication check in UI
   * - Conditional rendering
   * - Route protection (ProtectedRoute component)
   * - Initial app load decision
   * 
   * Note: This only checks token existence, not validity.
   * Token could be expired or invalid. Use verifyToken() for
   * actual validation.
   * 
   * @method isAuthenticated
   * @returns {boolean} True if token exists, false otherwise
   * 
   * @example
   * // Check authentication status
   * if (AuthService.isAuthenticated()) {
   *   console.log('User is logged in');
   * } else {
   *   console.log('User is not logged in');
   * }
   * 
   * @example
   * // Conditional rendering
   * function App() {
   *   return (
   *     &lt;div>
   *       {AuthService.isAuthenticated() ? (
   *         &lt;Dashboard />
   *       ) : (
   *         &lt;Login />
   *       )}
   *     &lt;/div>
   *   );
   * }
   * 
   * @example
   * // In ProtectedRoute
   * function ProtectedRoute({ children }) {
   *   if (!AuthService.isAuthenticated()) {
   *     return &lt;Navigate to="/login" />;
   *   }
   *   return children;
   * }
   */
  isAuthenticated() {
    return TokenManager.isAuthenticated();
  }


  /**
   * Handle and format API errors
   * 
   * Private method that extracts meaningful error messages from Axios
   * error objects and returns standardized Error instances.
   * 
   * Error Priority:
   * 1. Backend error message (response.data.message)
   * 2. Axios error message
   * 3. Generic fallback message
   * 
   * Error Object Structure:
   * - error.response: HTTP response from backend
   * - error.response.data: Response body (contains message)
   * - error.message: Axios error message
   * - Fallback: "An error occurred"
   * 
   * Common Error Messages:
   * - "Invalid credentials" (401)
   * - "Email already exists" (409)
   * - "Token expired" (401)
   * - "User not found" (404)
   * - "Server error" (500)
   * 
   * @private
   * @method _handleError
   * @param {Error} error - Axios error object
   * @returns {Error} Formatted Error instance with user-friendly message
   * 
   * @example
   * // Internal usage
   * try {
   *   await this.apiClient.post('/auth/login', credentials);
   * } catch (error) {
   *   throw this._handleError(error);
   * }
   */
  _handleError(error) {
    // Extract error message with priority:
    // 1. Backend message (most specific)
    // 2. Axios message (network/request error)
    // 3. Generic fallback
    const message = 
      error.response?.data?.message || 
      error.message || 
      'An error occurred';
    
    // Return new Error instance with extracted message
    return new Error(message);
  }
}


/**
 * Singleton AuthService Instance
 * 
 * Single shared instance exported for use throughout the application.
 * Ensures consistent state and configuration.
 * 
 * Import and use directly:
 * 
 * @example
 * import AuthService from './services/AuthService';
 * 
 * @type {AuthService}
 * @constant
 * @default
 */
export default new AuthService();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_auth_LoginForm.html">components/auth/LoginForm</a></li><li><a href="module-components_auth_SignupForm.html">components/auth/SignupForm</a></li><li><a href="module-components_common_Input.html">components/common/Input</a></li><li><a href="module-components_common_ProtectedRoute.html">components/common/ProtectedRoute</a></li><li><a href="module-components_layout_Header.html">components/layout/Header</a></li><li><a href="module-context_AuthContext.html">context/AuthContext</a></li><li><a href="module-services_ApiClient.html">services/ApiClient</a></li><li><a href="module-services_AuthService.html">services/AuthService</a></li><li><a href="module-utils_TokenManager.html">utils/TokenManager</a></li></ul><h3>Classes</h3><ul><li><a href="module-services_ApiClient-ApiClient.html">ApiClient</a></li><li><a href="module-services_AuthService-AuthService.html">AuthService</a></li><li><a href="module-utils_TokenManager-TokenManager.html">TokenManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Dec 16 2025 02:17:08 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>

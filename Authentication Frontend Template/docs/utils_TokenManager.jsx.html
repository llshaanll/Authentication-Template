<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/TokenManager.jsx</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/TokenManager.jsx</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Token Manager Utility
 * 
 * Centralized utility for managing JWT tokens and authentication data in browser
 * localStorage. Provides a clean, consistent API for storing, retrieving, and
 * clearing authentication state with built-in error handling.
 * 
 * SOLID Principles Implementation:
 * 
 * 1. Single Responsibility Principle (SRP):
 *    - Only handles token and session storage operations
 *    - Does not handle API calls or authentication logic
 *    - Focuses solely on localStorage interactions
 * 
 * 2. Open/Closed Principle (OCP):
 *    - Open for extension (can add sessionStorage, cookies, IndexedDB)
 *    - Closed for modification (existing methods stable)
 *    - Can be subclassed for different storage strategies
 * 
 * 3. Liskov Substitution Principle (LSP):
 *    - Can be replaced with alternative storage implementation
 *    - Interface contract maintained (getToken, saveAuthData, etc.)
 *    - Mock implementations possible for testing
 * 
 * 4. Interface Segregation Principle (ISP):
 *    - Small, focused methods (not monolithic)
 *    - Each method has single purpose
 *    - Clients use only what they need
 * 
 * 5. Dependency Inversion Principle (DIP):
 *    - High-level modules depend on this abstraction
 *    - Not dependent on concrete storage implementation
 *    - Could be swapped with alternative storage (cookies, sessionStorage)
 * 
 * Storage Strategy: localStorage
 * - Persistent across browser sessions
 * - Survives page refreshes
 * - Cleared only on logout or manual deletion
 * - Accessible across all tabs (same origin)
 * - 5-10MB storage limit (browser dependent)
 * 
 * Security Considerations:
 * - localStorage accessible via JavaScript (XSS vulnerability)
 * - Not accessible from other origins (CORS protection)
 * - Should only store non-sensitive data
 * - JWT tokens are generally safe (short expiration)
 * - Never store passwords or payment info
 * - Use HTTPS to prevent token interception
 * 
 * Alternative Storage Options:
 * - sessionStorage: Tab-specific, cleared on tab close
 * - Cookies: HTTP-only option (immune to XSS)
 * - IndexedDB: Larger storage, async API
 * - Memory: Most secure, lost on refresh
 * 
 * Features:
 * - Persistent token storage
 * - User data caching
 * - Session ID management
 * - Error-safe operations
 * - JSON serialization/deserialization
 * - Authentication state checking
 * - Complete data cleanup
 * 
 * @module utils/TokenManager
 * 
 * @author mr.shaan
 * @version 1.0.0
 * @since 2025-12-16
 * 
 * @example
 * // Save authentication data after login
 * import TokenManager from './utils/TokenManager';
 * 
 * TokenManager.saveAuthData(token, user, sessionId);
 * 
 * @example
 * // Check if user is authenticated
 * if (TokenManager.isAuthenticated()) {
 *   const user = TokenManager.getUser();
 *   console.log('Logged in as:', user.name);
 * }
 * 
 * @example
 * // Clear auth data on logout
 * TokenManager.clearAuthData();
 */


/**
 * TokenManager Class
 * 
 * Singleton utility class that encapsulates all localStorage operations
 * related to authentication. Provides consistent key naming, error handling,
 * and a clean API for auth data management.
 * 
 * Design Pattern: Singleton
 * - Single instance shared across application
 * - Consistent storage key naming
 * - Centralized error handling
 * 
 * Storage Keys:
 * - auth_token: JWT access token string
 * - auth_user: Serialized user object (JSON)
 * - auth_session: Session ID string (optional)
 * 
 * Data Types:
 * - Token: String (JWT format: header.payload.signature)
 * - User: Object (JSON serialized)
 * - Session: String (UUID or session identifier)
 * 
 * @class TokenManager
 * 
 * @example
 * // Class is exported as singleton
 * import TokenManager from './utils/TokenManager';
 * 
 * // Use directly without instantiation
 * TokenManager.saveAuthData(token, user);
 */
class TokenManager {
  /**
   * Initializes TokenManager with storage key constants
   * 
   * Sets up immutable storage keys used for localStorage operations.
   * Keys are prefixed with 'auth_' for namespace isolation.
   * 
   * Key Naming Convention:
   * - Prefix: 'auth_' (prevents conflicts with other app data)
   * - Descriptive: Clearly indicates stored content
   * - Consistent: Same format across all keys
   * 
   * @constructor
   * 
   * @example
   * // Internal instantiation (singleton pattern)
   * const tokenManager = new TokenManager();
   * export default tokenManager;
   */
  constructor() {
    /**
     * Storage key for JWT access token
     * @type {string}
     * @readonly
     * @constant
     * @default 'auth_token'
     */
    this.TOKEN_KEY = 'auth_token';

    /**
     * Storage key for user object (JSON)
     * @type {string}
     * @readonly
     * @constant
     * @default 'auth_user'
     */
    this.USER_KEY = 'auth_user';

    /**
     * Storage key for session identifier
     * @type {string}
     * @readonly
     * @constant
     * @default 'auth_session'
     */
    this.SESSION_KEY = 'auth_session';
  }


  /**
   * Saves authentication data to localStorage
   * 
   * Stores JWT token, user object, and optional session ID in localStorage
   * for persistent authentication across browser sessions and page refreshes.
   * 
   * Storage Operations:
   * 1. Store raw JWT token string
   * 2. Serialize and store user object as JSON
   * 3. Store session ID if provided
   * 4. Handle any localStorage errors gracefully
   * 
   * Error Scenarios:
   * - localStorage full (quota exceeded)
   * - localStorage disabled (privacy mode)
   * - JSON serialization error (circular references)
   * - Browser permissions denied
   * 
   * Error Handling:
   * - Catches all errors silently
   * - Logs errors to console
   * - Does not throw (prevents app crash)
   * - Graceful degradation (app continues)
   * 
   * Security Note:
   * - Token stored as plaintext (vulnerable to XSS)
   * - Use HTTPS to prevent token interception
   * - Keep token expiration short (24h recommended)
   * - Clear sensitive data on logout
   * 
   * @method saveAuthData
   * @param {string} token - JWT access token from backend
   * @param {Object} user - User object with profile data
   * @param {string} user.id - User UUID
   * @param {string} user.name - User's full name
   * @param {string} user.email - User's email address
   * @param {string} [user.contact] - User's contact number
   * @param {string} [sessionId=null] - Optional session identifier
   * 
   * @returns {void}
   * 
   * @example
   * // Save after successful login
   * const loginResponse = await api.post('/auth/login', credentials);
   * const { token, user, sessionId } = loginResponse.data;
   * 
   * TokenManager.saveAuthData(token, user, sessionId);
   * 
   * @example
   * // Save without session ID
   * TokenManager.saveAuthData(token, user);
   * 
   * @example
   * // With error handling in caller
   * try {
   *   TokenManager.saveAuthData(token, user);
   *   console.log('Auth data saved successfully');
   * } catch (error) {
   *   // Errors are caught internally and logged
   *   // This catch won't execute
   * }
   */
  saveAuthData(token, user, sessionId = null) {
    try {
      // Store JWT token as-is (string)
      localStorage.setItem(this.TOKEN_KEY, token);

      // Serialize user object to JSON string
      // Required because localStorage only stores strings
      localStorage.setItem(this.USER_KEY, JSON.stringify(user));

      // Store session ID if provided
      if (sessionId) {
        localStorage.setItem(this.SESSION_KEY, sessionId);
      }
    } catch (error) {
      // Log error but don't throw (graceful degradation)
      // Possible errors:
      // - QuotaExceededError: localStorage full
      // - SecurityError: localStorage disabled
      // - TypeError: Invalid user object
      console.error('Failed to save auth data:', error);
    }
  }


  /**
   * Retrieves JWT token from localStorage
   * 
   * Gets the stored JWT access token used for API authentication.
   * Token is automatically injected into API requests by ApiClient.
   * 
   * Token Format:
   * - JWT: header.payload.signature (Base64 encoded)
   * - Example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   * 
   * Token Contents (payload):
   * - userId: User identifier
   * - sessionId: Session identifier
   * - exp: Expiration timestamp
   * - iat: Issued at timestamp
   * 
   * Use Cases:
   * - API request authentication (Authorization header)
   * - Check if user is logged in
   * - Token verification with backend
   * - Session restoration on page load
   * 
   * @method getToken
   * @returns {string|null} JWT token string or null if not found
   * 
   * @example
   * // Get token for API call
   * const token = TokenManager.getToken();
   * if (token) {
   *   config.headers.Authorization = `Bearer ${token}`;
   * }
   * 
   * @example
   * // Check token existence
   * if (TokenManager.getToken()) {
   *   console.log('User has token');
   * } else {
   *   console.log('User not logged in');
   * }
   * 
   * @example
   * // Used in ApiClient interceptor
   * this.client.interceptors.request.use((config) => {
   *   const token = TokenManager.getToken();
   *   if (token) {
   *     config.headers.Authorization = `Bearer ${token}`;
   *   }
   *   return config;
   * });
   */
  getToken() {
    return localStorage.getItem(this.TOKEN_KEY);
  }


  /**
   * Retrieves user data from localStorage
   * 
   * Gets the stored user object that was saved during login.
   * Automatically deserializes JSON string back to JavaScript object.
   * 
   * User Object Structure:
   * - id: User UUID (primary key)
   * - name: Full name
   * - email: Email address
   * - contact: Phone number (optional)
   * - createdAt: Account creation date
   * 
   * Data Freshness:
   * - Cached data from login response
   * - May be stale if updated elsewhere
   * - For fresh data, call API endpoint
   * - Consider periodic refresh
   * 
   * Error Handling:
   * - Catches JSON.parse errors
   * - Returns null on invalid JSON
   * - Logs parsing errors
   * - Never throws errors
   * 
   * Use Cases:
   * - Display user profile info
   * - Show user name in header
   * - Pre-fill forms with user data
   * - Check user permissions/roles
   * 
   * @method getUser
   * @returns {Object|null} User object or null if not found/invalid
   * @returns {string} return.id - User UUID
   * @returns {string} return.name - User's full name
   * @returns {string} return.email - User's email address
   * @returns {string} [return.contact] - User's phone number
   * @returns {string} return.createdAt - ISO 8601 timestamp
   * 
   * @example
   * // Get current user
   * const user = TokenManager.getUser();
   * if (user) {
   *   console.log(`Welcome back, ${user.name}!`);
   * }
   * 
   * @example
   * // Display in component
   * function UserProfile() {
   *   const user = TokenManager.getUser();
   *   
   *   if (!user) {
   *     return &lt;Redirect to="/login" />;
   *   }
   *   
   *   return (
   *     &lt;div>
   *       &lt;h1>{user.name}&lt;/h1>
   *       &lt;p>{user.email}&lt;/p>
   *     &lt;/div>
   *   );
   * }
   * 
   * @example
   * // Handle corrupted data
   * const user = TokenManager.getUser();
   * if (!user) {
   *   // Data corrupted or not logged in
   *   TokenManager.clearAuthData();
   *   navigate('/login');
   * }
   */
  getUser() {
    try {
      // Retrieve serialized user string
      const user = localStorage.getItem(this.USER_KEY);

      // Parse JSON string back to object
      // Returns null if user is null/undefined
      return user ? JSON.parse(user) : null;
    } catch (error) {
      // JSON parsing failed (corrupted data)
      // Log error and return null
      console.error('Failed to parse user data:', error);
      return null;
    }
  }


  /**
   * Retrieves session ID from localStorage
   * 
   * Gets the stored session identifier that tracks the current user session.
   * Session ID is used for session management and multi-device tracking.
   * 
   * Session Management:
   * - Each login creates new session
   * - Session tracked in database (user_sessions table)
   * - Used for logout operations
   * - Enables "logout all devices" feature
   * 
   * Session ID Format:
   * - UUID v4 format
   * - Example: 550e8400-e29b-41d4-a716-446655440000
   * - Generated by backend on login
   * 
   * Use Cases:
   * - Logout current device only
   * - Track active sessions
   * - Multi-device session management
   * - Session analytics
   * 
   * @method getSessionId
   * @returns {string|null} Session UUID or null if not found
   * 
   * @example
   * // Get session ID for logout
   * const sessionId = TokenManager.getSessionId();
   * if (sessionId) {
   *   await api.post('/auth/logout', { sessionId });
   * }
   * 
   * @example
   * // Check active session
   * const sessionId = TokenManager.getSessionId();
   * if (sessionId) {
   *   const sessions = await api.get('/auth/sessions');
   *   const currentSession = sessions.find(s => s.id === sessionId);
   *   console.log('Current device:', currentSession.device);
   * }
   */
  getSessionId() {
    return localStorage.getItem(this.SESSION_KEY);
  }


  /**
   * Clears all authentication data from localStorage
   * 
   * Removes all stored authentication-related data including token,
   * user object, and session ID. Called on logout and authentication errors.
   * 
   * Cleanup Operations:
   * 1. Remove JWT token
   * 2. Remove user object
   * 3. Remove session ID
   * 4. Leaves other localStorage data intact
   * 
   * When to Call:
   * - User logout (manual or automatic)
   * - Token expired (401 response)
   * - Token verification failed
   * - User account deleted
   * - Security breach detected
   * 
   * Side Effects:
   * - User appears logged out immediately
   * - Protected routes become inaccessible
   * - API calls will fail with 401
   * - App state reset to unauthenticated
   * 
   * Security Note:
   * - Always call on logout (even if API fails)
   * - Ensures local state matches auth state
   * - Prevents stale token usage
   * - Client-side security measure
   * 
   * @method clearAuthData
   * @returns {void}
   * 
   * @example
   * // Clear on logout
   * const logout = async () => {
   *   try {
   *     await api.post('/auth/logout');
   *   } finally {
   *     TokenManager.clearAuthData();
   *     navigate('/login');
   *   }
   * };
   * 
   * @example
   * // Clear on 401 error (token expired)
   * if (error.response?.status === 401) {
   *   TokenManager.clearAuthData();
   *   window.location.href = '/login';
   * }
   * 
   * @example
   * // Clear on token verification failure
   * try {
   *   await verifyToken();
   * } catch (error) {
   *   TokenManager.clearAuthData();
   *   setUser(null);
   * }
   */
  clearAuthData() {
    // Remove JWT token
    localStorage.removeItem(this.TOKEN_KEY);

    // Remove user object
    localStorage.removeItem(this.USER_KEY);

    // Remove session ID
    localStorage.removeItem(this.SESSION_KEY);

    // Note: Does not clear other localStorage items
    // Only removes auth-specific data
  }


  /**
   * Checks if user is authenticated
   * 
   * Quick check for authentication status by verifying token existence.
   * Does NOT validate token signature or expiration - only checks presence.
   * 
   * Check Logic:
   * - Returns true if token string exists
   * - Returns false if token is null/undefined/empty
   * - Uses double negation (!!) to convert to boolean
   * 
   * Limitations:
   * - Does not verify token validity
   * - Does not check token expiration
   * - Does not validate with backend
   * - Token could be malformed or expired
   * 
   * When to Use:
   * - Initial UI rendering decisions
   * - Route protection (ProtectedRoute)
   * - Conditional component display
   * - Quick authentication checks
   * 
   * When NOT to Use:
   * - Before sensitive operations (use verifyToken instead)
   * - For security decisions (validate server-side)
   * - When token freshness matters
   * 
   * Validation Flow:
   * 1. Initial check: isAuthenticated() (quick)
   * 2. Verify token: verifyToken() (secure)
   * 3. Use authenticated state
   * 
   * @method isAuthenticated
   * @returns {boolean} True if token exists, false otherwise
   * 
   * @example
   * // Quick auth check
   * if (TokenManager.isAuthenticated()) {
   *   console.log('Token exists');
   * } else {
   *   console.log('No token found');
   * }
   * 
   * @example
   * // Conditional rendering
   * function App() {
   *   const isAuth = TokenManager.isAuthenticated();
   *   
   *   return (
   *     &lt;div>
   *       {isAuth ? &lt;Dashboard /> : &lt;Login />}
   *     &lt;/div>
   *   );
   * }
   * 
   * @example
   * // With token verification
   * const checkAuth = async () => {
   *   // Quick check first
   *   if (!TokenManager.isAuthenticated()) {
   *     return false;
   *   }
   *   
   *   // Verify token validity
   *   try {
   *     await AuthService.verifyToken();
   *     return true;
   *   } catch (error) {
   *     return false;
   *   }
   * };
   * 
   * @example
   * // In ProtectedRoute component
   * const { isAuthenticated, loading } = useAuth();
   * 
   * if (loading) {
   *   return &lt;LoadingSpinner />;
   * }
   * 
   * if (!isAuthenticated) {
   *   return &lt;Navigate to="/login" />;
   * }
   * 
   * return children;
   */
  isAuthenticated() {
    // Double negation (!!) converts truthy/falsy to boolean
    // Returns true if token exists and is non-empty string
    // Returns false if token is null, undefined, or empty string
    return !!this.getToken();
  }
}


/**
 * Singleton TokenManager Instance
 * 
 * Single shared instance exported for use throughout the application.
 * Ensures consistent storage key naming and centralized token management.
 * 
 * Import and use directly:
 * 
 * @example
 * import TokenManager from './utils/TokenManager';
 * 
 * @type {TokenManager}
 * @constant
 * @default
 */
export default new TokenManager();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_auth_LoginForm.html">components/auth/LoginForm</a></li><li><a href="module-components_auth_SignupForm.html">components/auth/SignupForm</a></li><li><a href="module-components_common_Input.html">components/common/Input</a></li><li><a href="module-components_common_ProtectedRoute.html">components/common/ProtectedRoute</a></li><li><a href="module-components_layout_Header.html">components/layout/Header</a></li><li><a href="module-context_AuthContext.html">context/AuthContext</a></li><li><a href="module-services_ApiClient.html">services/ApiClient</a></li><li><a href="module-services_AuthService.html">services/AuthService</a></li><li><a href="module-utils_TokenManager.html">utils/TokenManager</a></li></ul><h3>Classes</h3><ul><li><a href="module-services_ApiClient-ApiClient.html">ApiClient</a></li><li><a href="module-services_AuthService-AuthService.html">AuthService</a></li><li><a href="module-utils_TokenManager-TokenManager.html">TokenManager</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Tue Dec 16 2025 02:17:08 GMT+0530 (India Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
